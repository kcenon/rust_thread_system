# ì½”ë“œ ë¦¬ë·° ë° ì‹œìŠ¤í…œ ê°œì„  ì œì•ˆì„œ

**ë¦¬ë·°ì–´**: Lead Programmer
**í”„ë¡œì íŠ¸**: Rust Thread System v0.1.0
**ë¦¬ë·° ì¼ì**: 2025-11-06
**ì „ë°˜ì  í‰ê°€**: â˜…â˜…â˜…â˜…â˜† (4.5/5.0) - Production Ready with Enhancement Opportunities

---

## ëª©ì°¨

1. [ì „ë°˜ì  í‰ê°€](#1-ì „ë°˜ì -í‰ê°€)
2. [ê°•ì  ë¶„ì„](#2-ê°•ì -ë¶„ì„)
3. [ì¤‘ìš”ë„ë³„ ê°œì„  ì‚¬í•­](#3-ì¤‘ìš”ë„ë³„-ê°œì„ -ì‚¬í•­)
4. [ì„¸ë¶€ ì½”ë“œ ë¦¬ë·°](#4-ì„¸ë¶€-ì½”ë“œ-ë¦¬ë·°)
5. [ì•„í‚¤í…ì²˜ ê°œì„  ì œì•ˆ](#5-ì•„í‚¤í…ì²˜-ê°œì„ -ì œì•ˆ)
6. [ì„±ëŠ¥ ìµœì í™” ì œì•ˆ](#6-ì„±ëŠ¥-ìµœì í™”-ì œì•ˆ)
7. [ë³´ì•ˆ ë° ì•ˆì •ì„±](#7-ë³´ì•ˆ-ë°-ì•ˆì •ì„±)
8. [ê°œë°œì ê²½í—˜ ê°œì„ ](#8-ê°œë°œì-ê²½í—˜-ê°œì„ )
9. [ìš°ì„ ìˆœìœ„ë³„ ë¡œë“œë§µ](#9-ìš°ì„ ìˆœìœ„ë³„-ë¡œë“œë§µ)

---

## 1. ì „ë°˜ì  í‰ê°€

### 1.1 ìš”ì•½

ì´ Rust Thread Systemì€ **í”„ë¡œë•ì…˜ í™˜ê²½ì— ì¦‰ì‹œ íˆ¬ì… ê°€ëŠ¥í•œ ìˆ˜ì¤€**ì˜ ì˜ ì„¤ê³„ëœ ì½”ë“œë² ì´ìŠ¤ì…ë‹ˆë‹¤. íŠ¹íˆ ë‹¤ìŒ ì ì—ì„œ ë›°ì–´ë‚©ë‹ˆë‹¤:

- âœ… **ë©”ëª¨ë¦¬ ì•ˆì „ì„±**: 100% Safe Rustë¡œ êµ¬í˜„
- âœ… **ì—ëŸ¬ ì²˜ë¦¬**: í¬ê´„ì ì´ê³  ëª…í™•í•œ ì—ëŸ¬ íƒ€ì… ì •ì˜
- âœ… **í…ŒìŠ¤íŠ¸ ì»¤ë²„ë¦¬ì§€**: ë‹¨ìœ„/í†µí•©/ì†ì„± ê¸°ë°˜ í…ŒìŠ¤íŠ¸ ëª¨ë‘ êµ¬ë¹„
- âœ… **API ì„¤ê³„**: ëª…í™•í•˜ê³  ì§ê´€ì ì¸ ì¸í„°í˜ì´ìŠ¤
- âœ… **ë¬¸ì„œí™”**: ì ì ˆí•œ ìˆ˜ì¤€ì˜ ì½”ë“œ ë¬¸ì„œ ë° ì˜ˆì œ

### 1.2 í•µì‹¬ ì§€í‘œ

| í•­ëª© | í‰ê°€ | ì ìˆ˜ |
|------|------|------|
| ì½”ë“œ í’ˆì§ˆ | Excellent | 5/5 |
| ì•„í‚¤í…ì²˜ ì„¤ê³„ | Very Good | 4.5/5 |
| ì„±ëŠ¥ | Good | 4/5 |
| í…ŒìŠ¤íŠ¸ ì»¤ë²„ë¦¬ì§€ | Very Good | 4.5/5 |
| ë¬¸ì„œí™” | Good | 4/5 |
| í™•ì¥ì„± | Good | 4/5 |
| **ì „ì²´ í‰ê· ** | **Very Good** | **4.5/5** |

### 1.3 í”„ë¡œë•ì…˜ ì í•©ì„±

**ì¦‰ì‹œ í”„ë¡œë•ì…˜ íˆ¬ì… ê°€ëŠ¥**, ë‹¨ ë‹¤ìŒ ì‹œë‚˜ë¦¬ì˜¤ì—ì„œëŠ” ì¶”ê°€ ê°œì„  ê¶Œì¥:

- ğŸŸ¢ **ì í•©**: ì¼ë°˜ì ì¸ ë°±ê·¸ë¼ìš´ë“œ ì‘ì—… ì²˜ë¦¬, ì›¹ ì„œë²„ ì›Œì»¤ í’€
- ğŸŸ¡ **ê°œì„  í›„ ì í•©**: ê³ ì„±ëŠ¥ ê¸ˆìœµ ì‹œìŠ¤í…œ, ì‹¤ì‹œê°„ ë°ì´í„° ì²˜ë¦¬
- ğŸ”´ **ì¶”ê°€ ê°œë°œ í•„ìš”**: ìš°ì„ ìˆœìœ„ ìŠ¤ì¼€ì¤„ë§ì´ í•„ìˆ˜ì¸ ì‹œìŠ¤í…œ

---

## 2. ê°•ì  ë¶„ì„

### 2.1 ì•„í‚¤í…ì²˜ì  ê°•ì 

#### 2.1.1 ëª…í™•í•œ ê´€ì‹¬ì‚¬ ë¶„ë¦¬ (Separation of Concerns)

```
src/
â”œâ”€â”€ core/           # í•µì‹¬ ì¶”ìƒí™” (Job, Error, Cancellation)
â””â”€â”€ pool/           # êµ¬í˜„ ì„¸ë¶€ì‚¬í•­ (ThreadPool, Worker)
```

**í‰ê°€**: ëª¨ë“ˆ ê²½ê³„ê°€ ëª…í™•í•˜ê³  ì˜ì¡´ì„± ë°©í–¥ì´ ì˜¬ë°”ë¦„ (core â† pool)

#### 2.1.2 ì±„ë„ ê¸°ë°˜ Graceful Shutdown

**thread_pool.rs:373-393**
```rust
pub fn shutdown(&mut self) -> Result<()> {
    self.running.store(false, Ordering::Release);
    *self.sender.write() = None;  // ì±„ë„ ë‹¨ì ˆë¡œ ì›Œì»¤ ì¢…ë£Œ ì‹ í˜¸

    let workers = std::mem::take(&mut *self.workers.write());
    for worker in workers {
        worker.join()?;  // íì˜ ëª¨ë“  ì‘ì—… ì™„ë£Œ ëŒ€ê¸°
    }
    Ok(())
}
```

**ê°•ì **:
- Atomic flag ëŒ€ì‹  ì±„ë„ ë‹¨ì ˆ ì‚¬ìš© â†’ íì— ë‚¨ì€ ëª¨ë“  ì‘ì—…ì´ ì²˜ë¦¬ë¨ì„ ë³´ì¥
- RAII íŒ¨í„´ìœ¼ë¡œ ë¦¬ì†ŒìŠ¤ ëˆ„ìˆ˜ ë°©ì§€
- íƒ€ì„ì•„ì›ƒ ë©”ì»¤ë‹ˆì¦˜ìœ¼ë¡œ ë¬´í•œ ëŒ€ê¸° ë°©ì§€ (Worker::drop, line 218)

#### 2.1.3 Panic Isolation

**worker.rs:172**
```rust
let panic_result = catch_unwind(AssertUnwindSafe(|| job.execute()));
```

**ê°•ì **:
- í•˜ë‚˜ì˜ ì‘ì—… íŒ¨ë‹‰ì´ ì›Œì»¤ ìŠ¤ë ˆë“œë¥¼ ì£½ì´ì§€ ì•ŠìŒ
- íŒ¨ë‹‰ ë©”ì‹œì§€ ì¶”ì¶œ ë° ë¡œê¹…
- í†µê³„ì— ë³„ë„ ì¹´ìš´íŒ… (`jobs_panicked`)

### 2.2 ì½”ë“œ í’ˆì§ˆ

#### 2.2.1 íƒ€ì… ì•ˆì „ì„±

```rust
pub trait Job: Send {
    fn execute(&mut self) -> Result<()>;
}
```

- `Send` ë°”ìš´ë“œë¡œ ìŠ¤ë ˆë“œ ê°„ ì „ì†¡ ì•ˆì „ì„± ì»´íŒŒì¼ íƒ€ì„ ë³´ì¥
- `&mut self`ë¡œ ìƒíƒœë¥¼ ê°€ì§„ ì‘ì—… ì§€ì›
- Result íƒ€ì…ìœ¼ë¡œ ì—ëŸ¬ ì²˜ë¦¬ ê°•ì œ

#### 2.2.2 ë©”ëª¨ë¦¬ ìˆœì„œ ìµœì í™”

**thread_pool.rs:217, 240**
```rust
if !self.running.load(Ordering::Acquire) {  // ì¤‘ìš”: Acquire
    return Err(...);
}
// ...
self.queue_size.fetch_add(1, Ordering::Relaxed);  // í†µê³„: Relaxed
```

**ê°•ì **: í•„ìš”í•œ ê³³ì—ë§Œ ê°•í•œ ë©”ëª¨ë¦¬ ìˆœì„œ ì‚¬ìš©, ì„±ëŠ¥ ìµœì í™”

#### 2.2.3 TOCTOU Race Condition ë°©ì§€

**thread_pool.rs:181-190**
```rust
if self.running.compare_exchange(
    false, true,
    Ordering::AcqRel,
    Ordering::Acquire
).is_err() {
    return Err(ThreadError::already_running(...));
}
```

**ê°•ì **: Compare-and-swapìœ¼ë¡œ ë™ì‹œ start() í˜¸ì¶œ ì›ìì  ì²˜ë¦¬

### 2.3 í…ŒìŠ¤íŠ¸ ì „ëµ

- **ë‹¨ìœ„ í…ŒìŠ¤íŠ¸**: ê° ëª¨ë“ˆë³„ ì² ì €í•œ í…ŒìŠ¤íŠ¸
- **í†µí•© í…ŒìŠ¤íŠ¸**: ì‹¤ì œ ì‚¬ìš© ì‹œë‚˜ë¦¬ì˜¤ ê²€ì¦
- **ì†ì„± ê¸°ë°˜ í…ŒìŠ¤íŠ¸**: proptestë¡œ ì—£ì§€ ì¼€ì´ìŠ¤ íƒìƒ‰
- **ë²¤ì¹˜ë§ˆí¬**: Criterionìœ¼ë¡œ ì„±ëŠ¥ íšŒê·€ ê°ì§€

---

## 3. ì¤‘ìš”ë„ë³„ ê°œì„  ì‚¬í•­

### 3.1 ë†’ìŒ (High Priority) - í”„ë¡œë•ì…˜ í–¥ìƒì— ì¤‘ìš”

#### ğŸ”´ H-1: Job Result ë°˜í™˜ ë©”ì»¤ë‹ˆì¦˜ ë¶€ì¬

**í˜„ì¬ ìƒíƒœ**:
```rust
pool.execute(|| {
    println!("Result: {}", compute());  // ê²°ê³¼ë¥¼ ì¶œë ¥ë§Œ ê°€ëŠ¥
    Ok(())
})?;
// compute()ì˜ ê²°ê³¼ë¥¼ ë°›ì„ ë°©ë²•ì´ ì—†ìŒ
```

**ë¬¸ì œì **:
- ì‘ì—… ê²°ê³¼ë¥¼ ë°›ìœ¼ë ¤ë©´ ì‚¬ìš©ìê°€ ì§ì ‘ ì±„ë„/Arc<Mutex> êµ¬í˜„ í•„ìš”
- ì¼ë°˜ì ì¸ ì‚¬ìš© íŒ¨í„´ì¸ë° ë¼ì´ë¸ŒëŸ¬ë¦¬ê°€ ì§€ì›í•˜ì§€ ì•ŠìŒ

**ê°œì„ ì•ˆ**:
```rust
// ì œì•ˆ: execute_with_result ë©”ì„œë“œ ì¶”ê°€
let handle = pool.execute_with_result(|| {
    Ok(expensive_computation())
})?;

// NonBlocking ë°©ì‹
let result = handle.await_result()?;  // Result<T>

// ë˜ëŠ” Receiver<T> ë°˜í™˜
let receiver = handle.result_receiver();
match receiver.recv_timeout(Duration::from_secs(5)) {
    Ok(result) => println!("Got: {}", result),
    Err(_) => println!("Timeout"),
}
```

**êµ¬í˜„ ì˜ˆì‹œ**:
```rust
pub struct JobResult<T> {
    receiver: Receiver<Result<T>>,
}

impl ThreadPool {
    pub fn execute_with_result<F, T>(&self, f: F) -> Result<JobResult<T>>
    where
        F: FnOnce() -> Result<T> + Send + 'static,
        T: Send + 'static,
    {
        let (tx, rx) = bounded(1);
        self.execute(move || {
            let result = f();
            let _ = tx.send(result);
            Ok(())
        })?;
        Ok(JobResult { receiver: rx })
    }
}
```

**ì˜í–¥ë„**: ë†’ìŒ - ì‚¬ìš©ì„± ëŒ€í­ í–¥ìƒ
**êµ¬í˜„ ë‚œì´ë„**: ì¤‘ê°„
**ì˜ˆìƒ ê³µìˆ˜**: 1-2ì¼

---

#### ğŸ”´ H-2: ì›Œì»¤ë³„ í†µê³„ ì§‘ê³„ ì‹œ ë½ ë‚¨ìš©

**ë¬¸ì œ ì½”ë“œ** (thread_pool.rs:344-348):
```rust
pub fn total_jobs_processed(&self) -> u64 {
    let workers = self.workers.read();  // RwLock íšë“
    workers.iter().map(|w| w.stats().get_jobs_processed()).sum()
}
```

**ë¬¸ì œì **:
- `total_jobs_*()` ë©”ì„œë“œë“¤ì´ ë§¤ë²ˆ RwLock íšë“
- í•« íŒ¨ìŠ¤(hot path)ì—ì„œ í˜¸ì¶œ ì‹œ ê²½í•© ë°œìƒ ê°€ëŠ¥
- 3ê°œì˜ ë©”ì„œë“œê°€ ë…ë¦½ì ìœ¼ë¡œ ë½ íšë“ â†’ ë¹„íš¨ìœ¨

**ê°œì„ ì•ˆ 1**: ìºì‹±ëœ í†µê³„ êµ¬ì¡°ì²´ ë°˜í™˜
```rust
pub struct PoolStats {
    pub jobs_submitted: u64,
    pub jobs_processed: u64,
    pub jobs_failed: u64,
    pub jobs_panicked: u64,
    pub current_queue_size: u64,
    pub worker_stats: Vec<WorkerStat>,
}

impl ThreadPool {
    pub fn get_pool_stats(&self) -> PoolStats {
        let workers = self.workers.read();  // ë‹¨ 1íšŒ ë½ íšë“
        PoolStats {
            jobs_submitted: self.total_jobs_submitted.load(Ordering::Relaxed),
            jobs_processed: workers.iter().map(|w| w.stats().get_jobs_processed()).sum(),
            jobs_failed: workers.iter().map(|w| w.stats().get_jobs_failed()).sum(),
            jobs_panicked: workers.iter().map(|w| w.stats().get_jobs_panicked()).sum(),
            current_queue_size: self.queue_size.load(Ordering::Relaxed),
            worker_stats: workers.iter().map(|w| w.stats().snapshot()).collect(),
        }
    }
}
```

**ê°œì„ ì•ˆ 2**: í’€ ë ˆë²¨ ì§‘ê³„ ì¹´ìš´í„° (zero-lock)
```rust
pub struct ThreadPool {
    // ê¸°ì¡´ í•„ë“œë“¤...
    pool_stats: Arc<PoolStats>,  // ì›Œì»¤ê°€ ì§ì ‘ ì—…ë°ì´íŠ¸
}

// ì›Œì»¤ì—ì„œ ì‘ì—… ì™„ë£Œ ì‹œ:
pool_stats.jobs_processed.fetch_add(1, Ordering::Relaxed);
```

**íŠ¸ë ˆì´ë“œì˜¤í”„**:
- ë°©ì•ˆ 1: ìŠ¤ëƒ…ìƒ· ì½ê¸°, ì•½ê°„ì˜ ë½ ì˜¤ë²„í—¤ë“œ
- ë°©ì•ˆ 2: ë½ ì—†ìŒ, ì•½ê°„ì˜ ìºì‹œ ê²½í•© ê°€ëŠ¥

**ê¶Œì¥**: ë°©ì•ˆ 1 (ìŠ¤ëƒ…ìƒ·) - êµ¬í˜„ ë‹¨ìˆœ, ì¶©ë¶„íˆ ë¹ ë¦„

**ì˜í–¥ë„**: ì¤‘ìƒ - ëª¨ë‹ˆí„°ë§ ì„±ëŠ¥ í–¥ìƒ
**êµ¬í˜„ ë‚œì´ë„**: ë‚®ìŒ
**ì˜ˆìƒ ê³µìˆ˜**: 0.5ì¼

---

#### ğŸ”´ H-3: Priority Scheduling ë¯¸í†µí•©

**í˜„ì¬ ìƒíƒœ**:
- `priority.rs` ëª¨ë“ˆì€ êµ¬í˜„ë˜ì–´ ìˆìœ¼ë‚˜ ThreadPoolê³¼ í†µí•© ì•ˆ ë¨
- ì‹¤í—˜ì  ê¸°ëŠ¥(`priority-scheduling` feature)ì´ì§€ë§Œ ì‹¤ì œ ì‘ë™ ì•ˆ í•¨

**ê°œì„ ì•ˆ**:
```rust
#[cfg(feature = "priority-scheduling")]
pub fn submit_with_priority<J: Job + 'static>(
    &self,
    job: J,
    priority: Priority
) -> Result<()> {
    // PriorityQueue ì‚¬ìš©í•˜ë„ë¡ ThreadPool ë‚´ë¶€ ìˆ˜ì •
}
```

**êµ¬í˜„ ê³¼ì œ**:
1. ì±„ë„ì„ PriorityQueueë¡œ êµì²´ (ë˜ëŠ” ë³‘í–‰)
2. ì›Œì»¤ ë£¨í”„ì—ì„œ ìš°ì„ ìˆœìœ„ ê¸°ë°˜ polling
3. ì„±ëŠ¥ ì˜í–¥ ìµœì†Œí™”

**ëŒ€ì•ˆ**: ë³„ë„ì˜ `PriorityThreadPool` íƒ€ì… ì œê³µ
```rust
pub struct PriorityThreadPool { ... }  // priority-scheduling feature í™œì„±í™” ì‹œ
```

**ì˜í–¥ë„**: ì¤‘ìƒ - ê¸°ëŠ¥ ì™„ì„±ë„
**êµ¬í˜„ ë‚œì´ë„**: ë†’ìŒ (ì•„í‚¤í…ì²˜ ë³€ê²½ í•„ìš”)
**ì˜ˆìƒ ê³µìˆ˜**: 3-5ì¼

---

### 3.2 ì¤‘ê°„ (Medium Priority) - ì•ˆì •ì„± ë° ê´€ì°°ì„± í–¥ìƒ

#### ğŸŸ¡ M-1: Job íƒ€ì„ì•„ì›ƒ ë©”ì»¤ë‹ˆì¦˜ ë¶€ì¬

**í˜„ì¬ ë¬¸ì œ**:
- ë¬´í•œ ë£¨í”„ ì‘ì—…ì´ ì›Œì»¤ë¥¼ ì˜êµ¬ ì ìœ  ê°€ëŠ¥
- ì·¨ì†Œ í† í°ì€ í˜‘ë ¥ì (cooperative) - ì‘ì—…ì´ ì²´í¬í•´ì•¼ í•¨

**ê°œì„ ì•ˆ**:
```rust
pub fn execute_with_timeout<F>(
    &self,
    f: F,
    timeout: Duration
) -> Result<JobHandle>
where
    F: FnOnce() -> Result<()> + Send + 'static,
{
    let handle = JobHandle::new();
    let token = handle.token().clone();

    // ë³„ë„ ìŠ¤ë ˆë“œì—ì„œ íƒ€ì„ì•„ì›ƒ ê°ì‹œ
    let token_clone = token.clone();
    thread::spawn(move || {
        thread::sleep(timeout);
        token_clone.cancel();  // íƒ€ì„ì•„ì›ƒ ì‹œ ì·¨ì†Œ
    });

    self.submit_cancellable(move |token| {
        f()  // ì‚¬ìš©ìëŠ” ì—¬ì „íˆ token ì²´í¬ ê¶Œì¥
    })?;

    Ok(handle)
}
```

**ë” ë‚˜ì€ ë°©ë²•**: ì›Œì»¤ ë ˆë²¨ íƒ€ì„ì•„ì›ƒ (ê³ ê¸‰)
```rust
// Worker::run()ì—ì„œ
let job_timeout = Duration::from_secs(300);  // ì„¤ì • ê°€ëŠ¥
let start = Instant::now();

// ì‘ì—… ì‹¤í–‰ + íƒ€ì„ì•„ì›ƒ ê°ì‹œë¥¼ ë³„ë„ ìŠ¤ë ˆë“œì—ì„œ
let (result_tx, result_rx) = bounded(1);
thread::spawn(move || {
    result_tx.send(job.execute()).ok();
});

match result_rx.recv_timeout(job_timeout) {
    Ok(result) => handle_result(result),
    Err(_) => {
        stats.increment_timeout();
        // ì‘ì—… ê°•ì œ ì¢…ë£Œ ë¶ˆê°€ (Rust ì•ˆì „ì„±), ë¡œê¹…ë§Œ
        eprintln!("Job exceeded timeout");
    }
}
```

**íŠ¸ë ˆì´ë“œì˜¤í”„**: ìŠ¤ë ˆë“œ ìƒì„± ì˜¤ë²„í—¤ë“œ vs íƒ€ì„ì•„ì›ƒ ë³´ì¥

**ì˜í–¥ë„**: ì¤‘ìƒ
**êµ¬í˜„ ë‚œì´ë„**: ì¤‘ê°„
**ì˜ˆìƒ ê³µìˆ˜**: 2ì¼

---

#### ğŸŸ¡ M-2: ë™ì  ìŠ¤ë ˆë“œ í’€ í¬ê¸° ì¡°ì • ë¶ˆê°€

**í˜„ì¬ ì œì•½**:
- ìŠ¤ë ˆë“œ ìˆ˜ëŠ” start() ì‹œì ì— ê³ ì •
- ë¶€í•˜ ë³€í™”ì— ë”°ë¥¸ ë™ì  ì¡°ì • ë¶ˆê°€

**ê°œì„ ì•ˆ**: Auto-scaling ThreadPool
```rust
pub struct DynamicThreadPoolConfig {
    min_threads: usize,
    max_threads: usize,
    idle_timeout: Duration,         // ìœ íœ´ ì›Œì»¤ ì œê±° ì‹œê°„
    scale_up_threshold: f64,        // í í¬ê¸° > ì„ê³„ê°’ ì‹œ í™•ì¥
}

impl ThreadPool {
    // ë°±ê·¸ë¼ìš´ë“œ ëª¨ë‹ˆí„° ìŠ¤ë ˆë“œ
    fn monitor_and_scale(&self) {
        loop {
            let queue_size = self.queue_size();
            let active_workers = self.num_threads();

            if queue_size > active_workers * 10 {  // í™•ì¥
                self.add_worker()?;
            } else if active_workers > min_threads && idle_time > threshold {
                self.remove_idle_worker()?;  // ì¶•ì†Œ
            }

            thread::sleep(Duration::from_secs(5));
        }
    }
}
```

**ì£¼ì˜ì‚¬í•­**:
- ìŠ¤ë ˆë“œ ìƒì„±/ì œê±°ëŠ” ë¹„ìš©ì´ ë†’ìŒ â†’ ë³´ìˆ˜ì  ì •ì±… í•„ìš”
- Min/Max ë²”ìœ„ ì„¤ì •ìœ¼ë¡œ ì•ˆì •ì„± í™•ë³´

**ì˜í–¥ë„**: ì¤‘
**êµ¬í˜„ ë‚œì´ë„**: ë†’ìŒ
**ì˜ˆìƒ ê³µìˆ˜**: 4-5ì¼

---

#### ğŸŸ¡ M-3: êµ¬ì¡°í™”ëœ ë¡œê¹… ë¶€ì¬

**í˜„ì¬ ë¬¸ì œ**:
```rust
eprintln!("Worker {}: Job execution failed: {}", id, e);  // ë¹„êµ¬ì¡°í™” ë¡œê·¸
```

**ê°œì„ ì•ˆ**: `tracing` í¬ë ˆì´íŠ¸ ì‚¬ìš©
```rust
use tracing::{error, info, warn, instrument};

#[instrument(skip(job))]
fn execute_job(id: usize, job: &mut BoxedJob) -> Result<()> {
    info!(worker_id = id, job_type = job.job_type(), "Executing job");

    match job.execute() {
        Ok(()) => {
            info!(worker_id = id, "Job completed successfully");
            Ok(())
        }
        Err(e) => {
            error!(
                worker_id = id,
                error = %e,
                job_type = job.job_type(),
                "Job execution failed"
            );
            Err(e)
        }
    }
}
```

**ì¥ì **:
- êµ¬ì¡°í™”ëœ ë¡œê·¸ â†’ ì¿¼ë¦¬/ë¶„ì„ ìš©ì´
- ë‹¤ì–‘í•œ ë°±ì—”ë“œ(stdout, file, remote) ì§€ì›
- span/traceë¡œ ë¶„ì‚° ì¶”ì  ê°€ëŠ¥

**ì˜í–¥ë„**: ì¤‘
**êµ¬í˜„ ë‚œì´ë„**: ë‚®ìŒ
**ì˜ˆìƒ ê³µìˆ˜**: 1ì¼

---

#### ğŸŸ¡ M-4: Queue Full ì—ëŸ¬ ì‹œ ë°±í”„ë ˆì…” ë¶€ì¬

**í˜„ì¬ ë™ì‘**:
```rust
pool.execute(job)?;  // QueueFull ì‹œ ì¦‰ì‹œ ì—ëŸ¬ ë°˜í™˜
// ì‚¬ìš©ìê°€ ì§ì ‘ ì¬ì‹œë„ ë¡œì§ êµ¬í˜„ í•„ìš”
```

**ê°œì„ ì•ˆ**: ë‚´ì¥ ë°±í”„ë ˆì…” ì „ëµ
```rust
pub enum BackpressureStrategy {
    Fail,                          // í˜„ì¬ ë™ì‘ (ì¦‰ì‹œ ì—ëŸ¬)
    Block,                         // íì— ê³µê°„ ìƒê¸¸ ë•Œê¹Œì§€ ëŒ€ê¸°
    RetryWithBackoff {
        max_retries: u32,
        initial_delay: Duration,
    },
    DropOldest,                    // ê°€ì¥ ì˜¤ë˜ëœ ì‘ì—… ì œê±°
}

pub fn execute_with_backpressure<F>(
    &self,
    f: F,
    strategy: BackpressureStrategy,
) -> Result<()> { ... }
```

**êµ¬í˜„ ì˜ˆì‹œ** (Block ì „ëµ):
```rust
loop {
    match self.execute(f) {
        Ok(()) => break,
        Err(ThreadError::QueueFull { .. }) => {
            thread::sleep(Duration::from_millis(10));
            // ì¬ì‹œë„
        }
        Err(e) => return Err(e),
    }
}
```

**ì˜í–¥ë„**: ì¤‘
**êµ¬í˜„ ë‚œì´ë„**: ë‚®ìŒ
**ì˜ˆìƒ ê³µìˆ˜**: 1-2ì¼

---

### 3.3 ë‚®ìŒ (Low Priority) - í¸ì˜ì„± ê°œì„ 

#### ğŸŸ¢ L-1: ì¬ì‹œì‘ í›„ í†µê³„ ë¦¬ì…‹ ì•ˆ ë¨

**í˜„ì¬ ë™ì‘**:
```rust
pool.shutdown()?;
pool.start()?;
// total_jobs_submittedëŠ” ê³„ì† ëˆ„ì ë¨
```

**ê°œì„ ì•ˆ**:
```rust
pub fn start(&mut self) -> Result<()> {
    // ...
    if should_reset_stats {  // ì„¤ì • ê°€ëŠ¥
        self.total_jobs_submitted.store(0, Ordering::Relaxed);
    }
}
```

---

#### ğŸŸ¢ L-2: Builder íŒ¨í„´ìœ¼ë¡œ ThreadPool ìƒì„±

**í˜„ì¬**:
```rust
let config = ThreadPoolConfig::new(4)
    .with_max_queue_size(1000);
let pool = ThreadPool::with_config(config)?;
pool.start()?;
```

**ê°œì„ ì•ˆ**:
```rust
let pool = ThreadPool::builder()
    .num_threads(4)
    .max_queue_size(1000)
    .build_and_start()?;  // ìƒì„± + ì‹œì‘ì„ í•œ ë²ˆì—
```

---

#### ğŸŸ¢ L-3: ì‘ì—… ì´ë¦„/íƒœê·¸ ì¶”ê°€

**ê°œì„ ì•ˆ**:
```rust
pool.execute_named("data-sync", || { ... })?;

// í†µê³„ì—ì„œ ì‘ì—… íƒ€ì…ë³„ ì§‘ê³„
let stats = pool.get_stats_by_job_type();
// { "data-sync": 150, "image-resize": 320, ... }
```

---

## 4. ì„¸ë¶€ ì½”ë“œ ë¦¬ë·°

### 4.1 thread_pool.rs

#### ì´ìŠˆ 4.1.1: Queue Size Overflow ì²´í¬ì˜ ì‹¤ìš©ì„±

**ìœ„ì¹˜**: thread_pool.rs:232-237
```rust
if current_queue_size == u64::MAX {
    return Err(ThreadError::other(
        "Queue size counter overflow - this should never happen in practice",
    ));
}
```

**í‰ê°€**:
- ğŸ‘ ë°©ì–´ì  í”„ë¡œê·¸ë˜ë° ìš°ìˆ˜
- ğŸ¤” u64::MAXëŠ” ì‹¤ì§ˆì ìœ¼ë¡œ ë¶ˆê°€ëŠ¥ (18,446,744,073,709,551,615ê°œ)
- ğŸ’¡ ì œì•ˆ: Bounded queueì˜ ê²½ìš° `max_queue_size` ì²´í¬ê°€ ë” ìœ ì˜ë¯¸

**ê°œì„ ì•ˆ**:
```rust
if self.config.max_queue_size > 0 {
    let current = self.queue_size.load(Ordering::Relaxed);
    if current >= self.config.max_queue_size as u64 {
        return Err(ThreadError::queue_full(current, self.config.max_queue_size));
    }
}
```

---

#### ì´ìŠˆ 4.1.2: CancellableJobì˜ ì´ì¤‘ ì‹¤í–‰ ë°©ì§€

**ìœ„ì¹˜**: thread_pool.rs:109-115
```rust
if let Some(closure) = self.closure.take() {
    closure(self.token.clone())
} else {
    Err(ThreadError::other(
        "CancellableJob already executed - cannot execute twice",
    ))
}
```

**í‰ê°€**:
- ğŸ‘ Option::take()ë¡œ ì´ì¤‘ ì‹¤í–‰ ë°©ì§€
- ğŸ‘ ëª…í™•í•œ ì—ëŸ¬ ë©”ì‹œì§€
- âœ… íŒ¨í„´ ì ì ˆí•¨

---

#### ì´ìŠˆ 4.1.3: Drop ì‹œ ì—ëŸ¬ ì²˜ë¦¬

**ìœ„ì¹˜**: thread_pool.rs:396-408
```rust
impl Drop for ThreadPool {
    fn drop(&mut self) {
        if self.running.load(Ordering::Acquire) {
            if let Err(e) = self.shutdown() {
                eprintln!("[THREAD_POOL ERROR] Failed to shutdown...: {}", e);
            }
        }
    }
}
```

**í‰ê°€**:
- ğŸ‘ RAII íŒ¨í„´ ì¤€ìˆ˜
- ğŸ‘ ì´ë¯¸ ì¢…ë£Œëœ ê²½ìš° ìŠ¤í‚µ
- ğŸ¤” Dropì€ panic ë¶ˆê°€ â†’ eprintln! ì ì ˆ
- ğŸ’¡ ê³ ë ¤ì‚¬í•­: ì‘ìš© í”„ë¡œê·¸ë¨ì´ ë¡œê·¸ë¥¼ ëª» ë³¼ ìˆ˜ ìˆìŒ (stderr)

**ê°œì„ ì•ˆ**: Optional ë¡œê±° ì½œë°±
```rust
pub struct ThreadPoolConfig {
    // ...
    on_drop_error: Option<Box<dyn Fn(ThreadError) + Send + Sync>>,
}
```

---

### 4.2 worker.rs

#### ì´ìŠˆ 4.2.1: ì›Œì»¤ íƒ€ì„ì•„ì›ƒì˜ í•˜ë“œì½”ë”©

**ìœ„ì¹˜**: worker.rs:156
```rust
match receiver.recv_timeout(Duration::from_millis(100)) {
```

**í‰ê°€**:
- ğŸ¤” 100msëŠ” ì ì ˆí•˜ì§€ë§Œ ì„¤ì • ë¶ˆê°€
- ğŸ’¡ ì‘ë‹µì„± vs CPU ì‚¬ìš©ë¥  íŠ¸ë ˆì´ë“œì˜¤í”„

**ê°œì„ ì•ˆ**:
```rust
pub struct ThreadPoolConfig {
    // ...
    pub worker_poll_interval: Duration,  // ê¸°ë³¸ê°’ 100ms
}
```

**ì˜í–¥**: ì‘ìš© í”„ë¡œê·¸ë¨ë³„ ìµœì í™” ê°€ëŠ¥

---

#### ì´ìŠˆ 4.2.2: Queue Size ì–¸ë”í”Œë¡œìš° ë°©ì§€

**ìœ„ì¹˜**: worker.rs:159-167
```rust
queue_size.fetch_update(Ordering::Relaxed, Ordering::Relaxed, |size| {
    if size > 0 {
        Some(size - 1)
    } else {
        Some(0)  // ì–¸ë”í”Œë¡œìš° ë°©ì§€
    }
}).ok();
```

**í‰ê°€**:
- ğŸ‘ ìš°ìˆ˜í•œ ë°©ì–´ ì½”ë“œ
- ğŸ‘ `fetch_update`ë¡œ ì›ìì  ì²˜ë¦¬
- ğŸ’¡ `Some(0)` ì¼€ì´ìŠ¤ëŠ” ë²„ê·¸ ì‹ í˜¸ì¼ ìˆ˜ ìˆìŒ â†’ ë¡œê¹… ê³ ë ¤

**ê°œì„ ì•ˆ**:
```rust
let prev_size = queue_size.fetch_update(...).ok();
if prev_size == Some(0) {
    warn!("Queue size underflow detected - possible race condition");
}
```

---

#### ì´ìŠˆ 4.2.3: Drop ì‹œ 5ì´ˆ íƒ€ì„ì•„ì›ƒ

**ìœ„ì¹˜**: worker.rs:218
```rust
const JOIN_TIMEOUT: Duration = Duration::from_secs(5);
```

**í‰ê°€**:
- ğŸ‘ ë¬´í•œ ëŒ€ê¸° ë°©ì§€
- ğŸ¤” 5ì´ˆëŠ” ì„ì˜ì˜ ê°’
- ğŸ’¡ ì‘ì—…ì´ 5ì´ˆ ì´ìƒ ê±¸ë¦´ ìˆ˜ ìˆìŒ

**ê°œì„ ì•ˆ**: ì„¤ì • ê°€ëŠ¥í•˜ê²Œ
```rust
pub struct ThreadPoolConfig {
    pub worker_join_timeout: Duration,  // ê¸°ë³¸ 5ì´ˆ
}
```

---

### 4.3 job.rs

#### ì´ìŠˆ 4.3.1: Job Traitì˜ í™•ì¥ì„±

**ìœ„ì¹˜**: job.rs:7-24

**í˜„ì¬**:
```rust
pub trait Job: Send {
    fn execute(&mut self) -> Result<()>;
    fn job_type(&self) -> &str { "Job" }
    fn is_cancellable(&self) -> bool { false }
}
```

**í‰ê°€**:
- ğŸ‘ ìµœì†Œí•œì˜ í•„ìˆ˜ ë©”ì„œë“œ
- ğŸ‘ ê¸°ë³¸ êµ¬í˜„ ì œê³µ
- ğŸ’¡ í–¥í›„ í™•ì¥ ê°€ëŠ¥ì„± ê³ ë ¤ í•„ìš”

**í–¥í›„ í™•ì¥ ì œì•ˆ**:
```rust
pub trait Job: Send {
    fn execute(&mut self) -> Result<()>;
    fn job_type(&self) -> &str { "Job" }
    fn is_cancellable(&self) -> bool { false }

    // í–¥í›„ ì¶”ê°€ ê°€ëŠ¥
    fn priority(&self) -> Priority { Priority::Normal }
    fn estimated_duration(&self) -> Option<Duration> { None }
    fn tags(&self) -> &[&str] { &[] }
}
```

---

### 4.4 cancellation.rs

#### ì´ìŠˆ 4.4.1: Global Job ID ì¹´ìš´í„°

**ìœ„ì¹˜**: cancellation.rs:8-13
```rust
static NEXT_JOB_ID: AtomicU64 = AtomicU64::new(1);

fn next_job_id() -> u64 {
    NEXT_JOB_ID.fetch_add(1, Ordering::Relaxed)
}
```

**í‰ê°€**:
- ğŸ‘ lock-free êµ¬í˜„
- ğŸ‘ Relaxed ordering ì ì ˆ (ìˆœì„œë§Œ ì¤‘ìš”, ë™ê¸°í™” ë¶ˆí•„ìš”)
- ğŸ¤” í”„ë¡œì„¸ìŠ¤ë³„ ê³ ìœ  ID (ë¶„ì‚° ì‹œìŠ¤í…œì—ì„œëŠ” ì¶©ëŒ ê°€ëŠ¥)

**í–¥í›„ ê°œì„ **:
```rust
// ë¶„ì‚° í™˜ê²½ ëŒ€ë¹„ UUID ì˜µì…˜ ì œê³µ
pub struct JobHandle {
    job_id: JobId,  // enum { Sequential(u64), Uuid(Uuid) }
    token: CancellationToken,
}
```

---

#### ì´ìŠˆ 4.4.2: CancellationTokenì˜ ë©”ëª¨ë¦¬ ìˆœì„œ

**ìœ„ì¹˜**: cancellation.rs:62-72
```rust
pub fn cancel(&self) {
    self.cancelled.store(true, Ordering::Release);
}

pub fn is_cancelled(&self) -> bool {
    self.cancelled.load(Ordering::Acquire);
}
```

**í‰ê°€**:
- ğŸ‘ ì˜¬ë°”ë¥¸ Release-Acquire í˜ì–´ë§
- ğŸ‘ Happens-before ê´€ê³„ ë³´ì¥
- âœ… ë©”ëª¨ë¦¬ ëª¨ë¸ ì •í™•íˆ ì´í•´í•˜ê³  êµ¬í˜„

---

## 5. ì•„í‚¤í…ì²˜ ê°œì„  ì œì•ˆ

### 5.1 Work-Stealing ì•„í‚¤í…ì²˜

**í˜„ì¬**: Single shared queue (MPMC)

```
     submit()        submit()
        â†“               â†“
    [Shared Channel Queue]  â† ëª¨ë“  ì›Œì»¤ê°€ ë™ì¼ íì—ì„œ polling
        â†“       â†“       â†“
     Worker1 Worker2 Worker3
```

**ì œì•ˆ**: Work-Stealing with local queues

```
    submit() â†’ Router
        â†“
    [Global Queue]
     â†“      â†“      â†“
  [Q1]   [Q2]   [Q3]  â† ê° ì›Œì»¤ë³„ local queue
   â†“      â†“      â†“
  W1 â‡„  W2 â‡„  W3       â† ìœ íœ´ ì›Œì»¤ê°€ ë‹¤ë¥¸ ì›Œì»¤ íì—ì„œ steal
```

**ì¥ì **:
- ìºì‹œ ì§€ì—­ì„±(locality) í–¥ìƒ
- ê²½í•©(contention) ê°ì†Œ
- ìë™ ë¶€í•˜ ë¶„ì‚°

**êµ¬í˜„ ì°¸ê³ **: `crossbeam-deque` í¬ë ˆì´íŠ¸

**ì˜ˆìƒ ì„±ëŠ¥ í–¥ìƒ**: ì›Œì»¤ ìˆ˜ > 4ì¼ ë•Œ 20-30% ì²˜ë¦¬ëŸ‰ ì¦ê°€

---

### 5.2 ê³„ì¸µì  ìŠ¤ë ˆë“œ í’€

**ì œì•ˆ**: ì‘ì—… ìœ í˜•ë³„ ë…ë¦½ í’€

```rust
pub struct HierarchicalThreadPool {
    cpu_bound_pool: ThreadPool,      // CPU intensive
    io_bound_pool: ThreadPool,       // I/O wait
    high_priority_pool: ThreadPool,  // Latency-critical
}

impl HierarchicalThreadPool {
    pub fn submit_cpu_task<F>(&self, f: F) { ... }
    pub fn submit_io_task<F>(&self, f: F) { ... }
    pub fn submit_priority_task<F>(&self, f: F) { ... }
}
```

**ì‚¬ìš© ì‚¬ë¡€**:
- CPU ì‘ì—…: ì´ë¯¸ì§€ ì²˜ë¦¬, ì•”í˜¸í™”
- I/O ì‘ì—…: íŒŒì¼ ì½ê¸°, ë„¤íŠ¸ì›Œí¬ ìš”ì²­
- ê³ ìš°ì„ ìˆœìœ„: ì‚¬ìš©ì ìš”ì²­ ì²˜ë¦¬

---

### 5.3 Async/Await í†µí•©

**ì œì•ˆ**: Tokioì™€ì˜ ë¸Œë¦¬ì§€

```rust
pub fn execute_async<F, Fut>(&self, f: F) -> Result<()>
where
    F: FnOnce() -> Fut + Send + 'static,
    Fut: Future<Output = Result<()>> + Send,
{
    let handle = tokio::runtime::Handle::current();
    self.execute(move || {
        handle.block_on(f())
    })
}

// ë˜ëŠ” ë°˜ëŒ€ ë°©í–¥
pub async fn execute_sync<F>(&self, f: F) -> Result<()>
where
    F: FnOnce() -> Result<()> + Send + 'static,
{
    let (tx, rx) = tokio::sync::oneshot::channel();
    self.execute(move || {
        let result = f();
        tx.send(result).ok();
        Ok(())
    })?;
    rx.await.map_err(|_| ThreadError::other("Send failed"))?
}
```

---

## 6. ì„±ëŠ¥ ìµœì í™” ì œì•ˆ

### 6.1 ë²¤ì¹˜ë§ˆí¬ ê²°ê³¼ ê¸°ë°˜ ë¶„ì„

**ì˜ˆìƒ ë³‘ëª© ì§€ì **:
1. RwLock ê²½í•© (workers, sender)
2. Channel contention (bounded queue ì‚¬ìš© ì‹œ)
3. í†µê³„ ì§‘ê³„ ì˜¤ë²„í—¤ë“œ

### 6.2 ìµœì í™” ì „ëµ

#### 6.2.1 Lock-Free Statistics

**í˜„ì¬**:
```rust
pub fn get_stats(&self) -> Vec<Arc<WorkerStats>> {
    self.workers.read().iter().map(|w| w.stats()).collect()
}
```

**ê°œì„ **:
```rust
pub struct ThreadPool {
    worker_stats: Vec<Arc<WorkerStats>>,  // ë³„ë„ ì €ì¥, ë½ ë¶ˆí•„ìš”
}
```

#### 6.2.2 Batch Job Submission

**ì œì•ˆ**:
```rust
pub fn submit_batch<I>(&self, jobs: I) -> Result<usize>
where
    I: IntoIterator<Item = BoxedJob>,
{
    let sender = self.sender.read();
    let sender = sender.as_ref().ok_or(...)?;

    let mut count = 0;
    for job in jobs {
        sender.send(job)?;
        count += 1;
    }
    Ok(count)
}
```

**ì¥ì **: ë½ íšë“ 1íšŒë¡œ ì—¬ëŸ¬ ì‘ì—… ì œì¶œ

---

### 6.3 ë©”ëª¨ë¦¬ ìµœì í™”

#### 6.3.1 BoxedJob ëŒ€ì‹  Enum Dispatch

**í˜„ì¬**: `Box<dyn Job>` â†’ heap allocation + dynamic dispatch

**ê°œì„ ì•ˆ**:
```rust
pub enum JobType {
    Closure(ClosureJob<...>),
    Custom(Box<dyn Job>),
}
```

**ì¥ì **: í”í•œ ì¼€ì´ìŠ¤(closure)ëŠ” heap í• ë‹¹ ì—†ìŒ

---

## 7. ë³´ì•ˆ ë° ì•ˆì •ì„±

### 7.1 í˜„ì¬ ë³´ì•ˆ ìƒíƒœ

âœ… **ê°•ì **:
- 100% Safe Rust
- Panic ê²©ë¦¬
- íƒ€ì… ì•ˆì „ì„±

ğŸ” **ì£¼ì˜ì‚¬í•­**:
- Unbounded queue ì‚¬ìš© ì‹œ DoS ê°€ëŠ¥ (ë©”ëª¨ë¦¬ ê³ ê°ˆ)
  - âœ… ê¸°ë³¸ê°’ì´ bounded(10,000)ë¡œ ì™„í™”ë¨

### 7.2 ê¶Œì¥ ì‚¬í•­

#### 7.2.1 Rate Limiting

```rust
pub struct RateLimitedThreadPool {
    inner: ThreadPool,
    rate_limiter: Arc<Mutex<RateLimiter>>,
}

impl RateLimitedThreadPool {
    pub fn execute<F>(&self, f: F) -> Result<()> {
        self.rate_limiter.lock().unwrap().check_and_consume()?;
        self.inner.execute(f)
    }
}
```

#### 7.2.2 Resource Limits

```rust
pub struct ThreadPoolConfig {
    max_memory_mb: Option<usize>,      // ë©”ëª¨ë¦¬ ì œí•œ
    max_cpu_percent: Option<f64>,      // CPU ì‚¬ìš©ë¥  ì œí•œ
}
```

---

## 8. ê°œë°œì ê²½í—˜ ê°œì„ 

### 8.1 ì—ëŸ¬ ë©”ì‹œì§€ ê°œì„ 

**í˜„ì¬**:
```rust
Err(ThreadError::NotRunning { pool_name: "worker".into() })
```

**ê°œì„ **:
```rust
Err(ThreadError::NotRunning {
    pool_name: "worker".into(),
    hint: "Call pool.start() before submitting jobs".into(),
})
```

### 8.2 ì˜ˆì œ í™•ëŒ€

**ì œì•ˆ ì¶”ê°€ ì˜ˆì œ**:
- `web_server_integration.rs` - HTTP ì„œë²„ì™€ í†µí•©
- `database_connection_pool.rs` - DB ì‘ì—… ì²˜ë¦¬
- `file_processing_pipeline.rs` - íŒŒì¼ ì²˜ë¦¬ íŒŒì´í”„ë¼ì¸
- `monitoring_and_metrics.rs` - í”„ë¡œë©”í…Œìš°ìŠ¤ í†µí•©

### 8.3 ë¬¸ì„œí™” ê°•í™”

**ì¶”ê°€ í•„ìš” ë¬¸ì„œ**:
- ì•„í‚¤í…ì²˜ ì„¤ê³„ ë¬¸ì„œ (ARCHITECTURE.md)
- ë§ˆì´ê·¸ë ˆì´ì…˜ ê°€ì´ë“œ (ë‹¤ë¥¸ ìŠ¤ë ˆë“œ í’€ ë¼ì´ë¸ŒëŸ¬ë¦¬ì—ì„œ)
- íŠ¸ëŸ¬ë¸”ìŠˆíŒ… ê°€ì´ë“œ
- ì„±ëŠ¥ íŠœë‹ ê°€ì´ë“œ

---

## 9. ìš°ì„ ìˆœìœ„ë³„ ë¡œë“œë§µ

### Phase 1: Critical Improvements (2-3ì£¼)

| ì‘ì—… | ìš°ì„ ìˆœìœ„ | ê³µìˆ˜ | ì˜í–¥ë„ |
|------|---------|------|--------|
| H-1: Job Result ë°˜í™˜ | ğŸ”´ ë†’ìŒ | 2ì¼ | ì‚¬ìš©ì„± ëŒ€í­ í–¥ìƒ |
| H-2: í†µê³„ ì§‘ê³„ ìµœì í™” | ğŸ”´ ë†’ìŒ | 0.5ì¼ | ì„±ëŠ¥ 10-15% í–¥ìƒ |
| M-1: Job íƒ€ì„ì•„ì›ƒ | ğŸŸ¡ ì¤‘ê°„ | 2ì¼ | ì•ˆì •ì„± í–¥ìƒ |
| M-3: êµ¬ì¡°í™” ë¡œê¹… | ğŸŸ¡ ì¤‘ê°„ | 1ì¼ | ê´€ì°°ì„± í–¥ìƒ |
| M-4: ë°±í”„ë ˆì…” ì „ëµ | ğŸŸ¡ ì¤‘ê°„ | 1.5ì¼ | ì‚¬ìš©ì„± í–¥ìƒ |

**ì´ ì˜ˆìƒ ê³µìˆ˜**: 7ì¼

### Phase 2: Feature Completion (3-4ì£¼)

| ì‘ì—… | ìš°ì„ ìˆœìœ„ | ê³µìˆ˜ | ì˜í–¥ë„ |
|------|---------|------|--------|
| H-3: Priority Scheduling í†µí•© | ğŸ”´ ë†’ìŒ | 4ì¼ | ê¸°ëŠ¥ ì™„ì„± |
| M-2: ë™ì  ìŠ¤ë ˆë“œ í’€ | ğŸŸ¡ ì¤‘ê°„ | 5ì¼ | í™•ì¥ì„± í–¥ìƒ |
| í†µí•© í…ŒìŠ¤íŠ¸ ì¶”ê°€ | ğŸŸ¡ ì¤‘ê°„ | 2ì¼ | í’ˆì§ˆ í–¥ìƒ |
| ë¬¸ì„œ ë³´ê°• | ğŸŸ¢ ë‚®ìŒ | 3ì¼ | DX í–¥ìƒ |

**ì´ ì˜ˆìƒ ê³µìˆ˜**: 14ì¼

### Phase 3: Advanced Features (1-2ê°œì›”)

- Work-Stealing ì•„í‚¤í…ì²˜
- Async/Await í†µí•©
- Prometheus ë©”íŠ¸ë¦­ ë‚´ë³´ë‚´ê¸°
- ê³„ì¸µì  ìŠ¤ë ˆë“œ í’€
- ë¶„ì‚° ì‘ì—… í ì§€ì›

---

## 10. ê²°ë¡ 

### 10.1 ìµœì¢… í‰ê°€

Rust Thread Systemì€ **ì´ë¯¸ í”„ë¡œë•ì…˜ í™˜ê²½ì—ì„œ ì•ˆì •ì ìœ¼ë¡œ ì‚¬ìš© ê°€ëŠ¥í•œ ê³ í’ˆì§ˆ ì½”ë“œë² ì´ìŠ¤**ì…ë‹ˆë‹¤. íŠ¹íˆ ë‹¤ìŒ ì ì—ì„œ ë›°ì–´ë‚©ë‹ˆë‹¤:

1. **ê²¬ê³ ì„±**: ë©”ëª¨ë¦¬ ì•ˆì „ì„±, íŒ¨ë‹‰ ê²©ë¦¬, ì—ëŸ¬ ì²˜ë¦¬
2. **ëª…í™•ì„±**: ê¹¨ë—í•œ ì•„í‚¤í…ì²˜, ëª…í™•í•œ API
3. **í…ŒìŠ¤íŠ¸**: í¬ê´„ì ì¸ í…ŒìŠ¤íŠ¸ ì»¤ë²„ë¦¬ì§€
4. **ë¬¸ì„œ**: ì ì ˆí•œ ìˆ˜ì¤€ì˜ ë¬¸ì„œí™”

### 10.2 ê¶Œì¥ ì¡°ì¹˜

**ì¦‰ì‹œ ì ìš© (1ì£¼ ì´ë‚´)**:
- H-2: í†µê³„ ì§‘ê³„ ìµœì í™” (ë¹ ë¥¸ ìŠ¹ë¦¬)
- M-3: êµ¬ì¡°í™” ë¡œê¹… ì¶”ê°€ (ìš´ì˜ í•„ìˆ˜)
- L-2: Builder íŒ¨í„´ (ì‚¬ìš©ì„±)

**ë‹¨ê¸° (1ê°œì›” ì´ë‚´)**:
- H-1: Job Result ë°˜í™˜ (í•µì‹¬ ê¸°ëŠ¥)
- M-1: Job íƒ€ì„ì•„ì›ƒ (ì•ˆì •ì„±)
- M-4: ë°±í”„ë ˆì…” ì „ëµ (ì•ˆì •ì„±)

**ì¤‘ê¸° (3ê°œì›” ì´ë‚´)**:
- H-3: Priority Scheduling ì™„ì„±
- M-2: ë™ì  ìŠ¤ë ˆë“œ í’€
- ë¬¸ì„œ ë° ì˜ˆì œ í™•ëŒ€

**ì¥ê¸° (6ê°œì›”+)**:
- Work-Stealing ì•„í‚¤í…ì²˜
- Async í†µí•©
- ê³ ê¸‰ ê¸°ëŠ¥ (ë¶„ì‚° í ë“±)

### 10.3 ìµœì¢… ì˜ê²¬

ì´ í”„ë¡œì íŠ¸ëŠ” Rust ìƒíƒœê³„ì— í›Œë¥­í•œ ê¸°ì—¬ê°€ ë  ê²ƒì…ë‹ˆë‹¤. ëª‡ ê°€ì§€ ê°œì„  ì‚¬í•­ì„ í†µí•´ `rayon`, `threadpool` ë“± ê¸°ì¡´ ì†”ë£¨ì…˜ê³¼ ì°¨ë³„í™”ëœ ê°€ì¹˜ë¥¼ ì œê³µí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

íŠ¹íˆ:
- **Rayon**: ë°ì´í„° ë³‘ë ¬ì„±ì— íŠ¹í™” â†’ ìš°ë¦¬ëŠ” ì‘ì—… íì— íŠ¹í™”
- **Threadpool**: ê¸°ë³¸ ê¸°ëŠ¥ë§Œ ì œê³µ â†’ ìš°ë¦¬ëŠ” í†µê³„, ì·¨ì†Œ, ìš°ì„ ìˆœìœ„ ì œê³µ

**í”„ë¡œë•ì…˜ íˆ¬ì… ì˜ê²¬**: âœ… **ì¦‰ì‹œ ê°€ëŠ¥** (Phase 1 ê°œì„  í›„ ë”ìš± ì™„ë²½)

---

**ë¦¬ë·°ì–´**: Lead Programmer
**ì„œëª…**: [Signed]
**ë‚ ì§œ**: 2025-11-06
